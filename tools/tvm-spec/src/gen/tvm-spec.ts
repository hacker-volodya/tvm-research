/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * How instruction is named in [original TVM implementation](https://github.com/ton-blockchain/ton/blob/master/crypto/vm). Not necessarily unique (currently only DEBUG is not unique).
 */
export type InstructionName = string;
export type CategoryOfInstruction = string;
/**
 * Free-form markdown description of instruction.
 */
export type InstructionDescription = string;
/**
 * Free-form description of gas amount used by instruction.
 */
export type GasUsageInfo = string;
/**
 * Free-form fift usage description.
 */
export type FiftUsageDoc = string;
export type FiftSnippet = string;
export type ExampleDescription = string;
/**
 * Free-form bytecode format description.
 */
export type OpcodeFormatDocumentation = string;
/**
 * TL-b bytecode format description.
 */
export type TLBSchema = string;
/**
 * Prefix to determine next instruction to parse. It is a hex bitstring as in TL-b (suffixed with `_` if bit length is not divisible by 4, trailing `'1' + '0' * x` must be removed).
 */
export type InstructionPrefix = string;
/**
 * Allowed chars are `a-zA-Z0-9_`, must not begin with digit or underscore and must not end with underscore.
 */
export type OperandVariableName = string;
export type LoaderFunctionForOperand = "int" | "uint" | "ref" | "pushint_long" | "subslice";
/**
 * If true, this operand is used as a subslice length variable, should be used only for serialization/deserialization, humans and implementations do not need them.
 */
export type InternalFlag = boolean;
/**
 * Describes how to parse operands. Order of objects in this array represents the actual order of operands in instruction. Optional, no operands in case of absence.
 */
export type InstructionOperands = {
  name: OperandVariableName;
  loader: LoaderFunctionForOperand;
  loader_args?: ArgumentsForLoaderFunctionOptionalNoArgumentsInCaseOfAbsence;
  internal?: InternalFlag;
}[];
/**
 * Free-form description of stack inputs and outputs. Usually the form is `[inputs] - [outputs]` where `[inputs]` are consumed stack values and `outputs` are produced stack values (top of stack is the last value).
 */
export type StackUsageDescription = string;
/**
 * Representation of stack entry or group of stack entries
 */
export type StackEntry =
  | {
      type: "simple";
      name: VariableToPass;
      value_types?: PossibleValueTypes;
    }
  | {
      type: "const";
      value_type: ConstantType;
      value: ConstantValue;
    }
  | {
      type: "conditional";
      name: VariableToMatch;
      match: MatchArm[];
      else?: StackValues;
    }
  | {
      type: "array";
      name: VariableName;
      length_var: VariableWhichContainsArrayLength;
      array_entry: ArraySingleEntryDefinition;
    };
export type VariableToPass = string;
export type PossibleValueTypes = ("Integer" | "Cell" | "Builder" | "Slice" | "Tuple" | "Continuation" | "Null")[];
export type ConstantType = "Integer" | "Null";
export type ConstantValue = number | null;
export type VariableToMatch = string;
export type ArmValue = number;
export type VariableName = string;
export type VariableWhichContainsArrayLength = string;
/**
 * Array is a structure like `x1 y1 z1 x2 y2 z2 ... x_n y_n z_n n` which contains `n` entries of `x_i y_i z_i`. This property defines the structure of a single entry.
 */
export type ArraySingleEntryDefinition = StackValues;
/**
 * Stack constraints. Top of stack is the last value.
 */
export type StackValues = StackEntry[];
/**
 * Description of a continuation with static savelist
 */
export type Continuation =
  | {
      type: "cc";
      save?: ContinuationSavelist;
    }
  | {
      type: "variable";
      var_name: ContinuationVariableName;
      save?: ContinuationSavelist;
    }
  | {
      type: "register";
      index: RegisterNumber03;
      save?: ContinuationSavelist;
    }
  | {
      type: "special";
      name: "until";
      args: {
        body: Continuation;
        after: Continuation;
      };
    }
  | {
      type: "special";
      name: "while";
      args: {
        cond: Continuation;
        body: Continuation;
        after: Continuation;
      };
    }
  | {
      type: "special";
      name: "again";
      args: {
        body: Continuation;
      };
    }
  | {
      type: "special";
      name: "repeat";
      args: {
        count: VariableName1;
        body: Continuation;
        after: Continuation;
      };
    }
  | {
      type: "special";
      name: "pushint";
      args: {
        value: IntegerToPushToStack;
        next: Continuation;
      };
    };
export type ContinuationVariableName = string;
export type RegisterNumber03 = number;
export type VariableName1 = string;
export type IntegerToPushToStack = number;
/**
 * Array of current continuation possible values after current instruction execution
 */
export type PossibleBranchesOfAnInstruction = Continuation[];
/**
 * Can this instruction not perform any of specified branches in certain cases (do not modify cc)?
 */
export type NoBranchPossibility = boolean;
export type AliasName = string;
export type MnemonicOfAliasedInstruction = string;
/**
 * Free-form fift usage description.
 */
export type FiftUsageDoc1 = string;
/**
 * Free-form description of stack inputs and outputs. Usually the form is `[inputs] - [outputs]` where `[inputs]` are consumed stack values and `outputs` are produced stack values (top of stack is the last value).
 */
export type StackUsageDescription1 = string;
/**
 * Free-form markdown description of alias.
 */
export type AliasDescription = string;
/**
 * Aliases list.
 */
export type Aliases = Alias[];

export interface Schema {
  $schema?: string;
  /**
   * Instruction list.
   */
  instructions: Instruction[];
  aliases: Aliases;
}
export interface Instruction {
  mnemonic: InstructionName;
  doc: Documentation;
  bytecode: BytecodeFormat;
  value_flow?: ValueFlowOfInstruction;
  control_flow?: ControlFlowOfInstruction;
}
/**
 * Free-form human-friendly information which should be used for documentation purposes only.
 */
export interface Documentation {
  category: CategoryOfInstruction;
  description?: InstructionDescription;
  gas?: GasUsageInfo;
  fift?: FiftUsageDoc;
  fift_examples?: {
    fift?: FiftSnippet;
    description?: ExampleDescription;
  }[];
}
/**
 * Information related to bytecode format of an instruction. Assuming that each instruction has format `prefix || operand_1 || operand_2 || ...` (also some operands may be refs, not bitstring part).
 */
export interface BytecodeFormat {
  doc_opcode?: OpcodeFormatDocumentation;
  tlb: TLBSchema;
  prefix: InstructionPrefix;
  operands_range_check?: OperandsRangeCheck;
  operands?: InstructionOperands;
}
/**
 * In TVM, it is possible for instructions to have overlapping prefixes, so to determine actual instruction it is required to read next `length` bits after prefix as uint `i` and check `from <= i <= to`. Optional, there is no operands check in case of absence.
 */
export interface OperandsRangeCheck {
  length: number;
  from: number;
  to: number;
}
export interface ArgumentsForLoaderFunctionOptionalNoArgumentsInCaseOfAbsence {
  [k: string]: unknown;
}
/**
 * Information related to usage of stack and registers by instruction.
 */
export interface ValueFlowOfInstruction {
  doc_stack?: StackUsageDescription;
  inputs?: InstructionInputs;
  outputs?: InstructionOutputs;
}
/**
 * Incoming values constraints. Input is unconstrained if absent.
 */
export interface InstructionInputs {
  stack: StackValues;
}
export interface MatchArm {
  value: ArmValue;
  stack: StackValues;
}
/**
 * Outgoing values constraints. Output is unconstrained if absent.
 */
export interface InstructionOutputs {
  stack: StackValues;
}
/**
 * Information related to current cc modification by instruction
 */
export interface ControlFlowOfInstruction {
  branches?: PossibleBranchesOfAnInstruction;
  nobranch?: NoBranchPossibility;
}
/**
 * Values of saved control flow registers c0-c3
 */
export interface ContinuationSavelist {
  c0?: Continuation;
  c1?: Continuation;
  c2?: Continuation;
  c3?: Continuation;
}
export interface Alias {
  mnemonic: AliasName;
  alias_of: MnemonicOfAliasedInstruction;
  doc_fift?: FiftUsageDoc1;
  doc_stack?: StackUsageDescription1;
  description?: AliasDescription;
  operands: FixedOperandsOfAlias;
}
/**
 * Values of original instruction operands which are fixed in this alias. Currently it can be integer or slice without references which is represented by string of '0' and '1's. Type should be inferred from original instruction operand loaders.
 */
export interface FixedOperandsOfAlias {
  [k: string]: unknown;
}
